# Data segment
- всички глобални и статични локални променливи с ненулева начална стойност

# Stack segment
- всички локални променливи, които се създават при изпълнение на функция(не са в bss и data)
- пазят се аргументи return стойностите, които са по-големи от регистрите на ядрото
- return pointer, за да видим откъде е започнала функцията и да се върнем там, откъдето сме тръгнали
- stack frame - локалните променливи, state, и горе долу за всяка функция се прави такова


# Heap segment
- динамично заделена памет

# Void pointer 
- size-а трябва да е достатъчно че да покрие цялата шина
16 битова адресна шина - сайза е 16 бита
трябва да е ПОНЕ

# BSS - Block Started by Symbol
- всички глобални и статични локални променливи с начална стойност 0 или без такава не се пазят в exe file за всички начални променливи се заделя памет само за тези, които имат ненулева начална стойност

# Constants
- може да са в data или bss или да си имат отделно парче памет. Могат и да са само и изпълнимия файл и оттм да си ги четем

# Shmit trigger
- нали имаме покачващ се и слизащ фронт и сега имаме не 1 ниво спрямо окето се мери, а две - едно за високо ниво и 1 за ниско ниво

## DDR - data direction register
- за всеки порт(група от пинове) има по 1 регистър от всеки вид(входове или изходи са, четене, писане)
- DDR B - дали пиновете на порта B са вход или изход
- PORT B - дали пиновете на порта B са високо или ниско ниво(HIGH or LOW) по default 
- Ако искаме да е входен пин-ът, трябва да му зададем DDR пинът на 0 и да прочетем през PIN регистъра

## DDR, PIN, PORT
- DDR - дали е вход или изход
- PIN - четем от пиновете
- PORT - пишем на пиновете

# Bitshifting in C
& - only 1and1 = 1  (1111 & 1010 = 1010)
<br>
| - 1 or 1 = 1 (1111 | 1010 = 1111)
<br>
~ - not 1 = 0 ( ~1010 = 0101)
<br>
^ - 1 xor 1 = 0 (1111 ^ 1010 = 0101)
<br>
<< - shift left (1010 << 1 = 0100) (00110101 << 2 = 11010100)
<br>
`>> - shift right (1010 >> 1 = 0101) (00110101 >> 2 = 00001101)
<br><br>
1 << n - 1 shifted n times to the left (1 << 3 = 1000)
<br>
